/*
문제 설명
바탕화면은 각 칸이 정사각형인 격자판.
바탕화면의 상태를 나타낸 문자열 배열 wallpaper가 주어진다.
파일들은 바탕화면의 격자칸에 위치.
가장 왼쪽 위를 (0, 0)으로 시작해 (세로 좌표, 가로 좌표)로 표현한다.
빈칸은 ".", 파일이 있는 칸은 "#"이다. 
최소한의 이동거리를 갖는 한 번의 드래그로 모든 파일을 선택해서 한 번에 지우려고 하며 드래그로 파일들을 선택하는 방법은 다음과 같다.

드래그는 바탕화면의 격자점 S(lux, luy)를 클릭한 상태로 격자점 E(rdx, rdy)로 이동. 
"점 S에서 점 E로 드래그한다"고 표현하고 점 S와 점 E를 각각 드래그의 시작점, 끝점이라고 표현한다.

점 S(lux, luy)에서 점 E(rdx, rdy)로 드래그를 할 때, "드래그 한 거리"는 |rdx - lux| + |rdy - luy|로 정의.

점 S에서 점 E로 드래그를 하면 두 격자점을 각각 왼쪽 위, 오른쪽 아래로 하는 직사각형 내부에 있는 모든 파일이 선택.

예를 들어 wallpaper = [".#...", "..#..", "...#."]인 바탕화면을 그림으로 나타내면 다음과 같다.
S(0, 1)에서 E(3, 4)로 드래그하면 세 개의 파일이 모두 선택되므로 드래그 한 거리 (3 - 0) + (4 - 1) = 6을 최솟값으로 모든 파일을 선택 가능.
(0, 0)에서 (3, 5)로 드래그해도 모든 파일을 선택할 수 있지만 이때 드래그 한 거리는 (3 - 0) + (5 - 0) = 8이고 이전의 방법보다 거리가 늘어남.

바탕화면의 상태를 나타내는 문자열 배열 wallpaper가 매개변수로 주어질 때 바탕화면의 파일들을 한 번에 삭제하기 위해 최소한의 이동거리를 갖는 드래그의 시작점과 끝점을 담은 정수 배열을 return하는 solution 함수를 작성해라. 
드래그의 시작점이 (lux, luy), 끝점이 (rdx, rdy)라면 정수 배열 [lux, luy, rdx, rdy]를 return.

제한사항
1 ≤ wallpaper의 길이 ≤ 50
1 ≤ wallpaper[i]의 길이 ≤ 50
wallpaper의 모든 원소의 길이는 동일.
wallpaper[i][j]는 바탕화면에서 i + 1행 j + 1열에 해당하는 칸의 상태를 나타냄.
wallpaper[i][j]는 "#" 또는 "."의 값만 가짐.
바탕화면에는 적어도 하나의 파일이 있음.
드래그 시작점 (lux, luy)와 끝점 (rdx, rdy)는 lux < rdx, luy < rdy를 만족해야함.

입출력 예
wallpaper	result
[".#...", "..#..", "...#."]	[0, 1, 3, 4]
["..........", ".....#....", "......##..", "...##.....", "....#....."]	[1, 3, 5, 8]
[".##...##.", "#..#.#..#", "#...#...#", ".#.....#.", "..#...#..", "...#.#...", "....#...."]	[0, 0, 7, 9]
["..", "#."]	[1, 0, 2, 1]
 */

function solution(wallpaper) {
  const xs = [];
  const ys = [];

  for (let i = 0; i < wallpaper.length; i++) {
    for (let j = 0; j < wallpaper[i].length; j++) {
      if (wallpaper[i][j] === "#") {
        xs.push(j);
        ys.push(i);
      }
    }
  }

  return [
    Math.min(...ys),
    Math.min(...xs),
    Math.max(...ys) + 1,
    Math.max(...xs) + 1,
  ];
}

let output1 = solution([".#...", "..#..", "...#."]); // -> [0, 1, 3, 4]
console.log(output1);

let output2 = solution([
  "..........",
  ".....#....",
  "......##..",
  "...##.....",
  "....#.....",
]); // -> [1, 3, 5, 8]
console.log(output2);

let output3 = solution([
  ".##...##.",
  "#..#.#..#",
  "#...#...#",
  ".#.....#.",
  "..#...#..",
  "...#.#...",
  "....#....",
]); // -> [0, 0, 7, 9]
console.log(output3);

let output4 = solution(["..", "#."]); // -> [1, 0, 2, 1]
console.log(output4);
